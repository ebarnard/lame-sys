// automatically generated by rust-bindgen

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]

extern crate libc;

use libc::FILE;
use std::os::raw::*;

pub type size_t = usize;

// TODO: va_list support
// pub type lame_report_function =
//    ::std::option::Option<unsafe extern "C" fn(format: *const c_char, ap: va_list)>;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum vbr_mode {
    vbr_off = 0,
    vbr_mt = 1,
    vbr_rh = 2,
    vbr_abr = 3,
    vbr_mtrh = 4,
    vbr_max_indicator = 5,
}
pub const vbr_default: vbr_mode = vbr_mode::vbr_mtrh;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum MPEG_mode {
    STEREO = 0,
    JOINT_STEREO = 1,
    DUAL_CHANNEL = 2,
    MONO = 3,
    NOT_SET = 4,
    MAX_INDICATOR = 5,
}

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Padding_type {
    PAD_NO = 0,
    PAD_ALL = 1,
    PAD_ADJUST = 2,
    PAD_MAX_INDICATOR = 3,
}

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum preset_mode {
    ABR_8 = 8,
    ABR_320 = 320,
    V9 = 410,
    V8 = 420,
    V7 = 430,
    V6 = 440,
    V5 = 450,
    V4 = 460,
    V3 = 470,
    V2 = 480,
    V1 = 490,
    V0 = 500,
    R3MIX = 1000,
    STANDARD = 1001,
    EXTREME = 1002,
    INSANE = 1003,
    STANDARD_FAST = 1004,
    EXTREME_FAST = 1005,
    MEDIUM = 1006,
    MEDIUM_FAST = 1007,
}

pub const VBR_10: preset_mode = preset_mode::V9;
pub const VBR_20: preset_mode = preset_mode::V8;
pub const VBR_30: preset_mode = preset_mode::V7;
pub const VBR_40: preset_mode = preset_mode::V6;
pub const VBR_50: preset_mode = preset_mode::V5;
pub const VBR_60: preset_mode = preset_mode::V4;
pub const VBR_70: preset_mode = preset_mode::V3;
pub const VBR_80: preset_mode = preset_mode::V2;
pub const VBR_90: preset_mode = preset_mode::V1;
pub const VBR_100: preset_mode = preset_mode::V0;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum asm_optimizations {
    MMX = 1,
    AMD_3DNOW = 2,
    SSE = 3,
}

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Psy_model {
    PSY_GPSYCHO = 1,
    PSY_NSPSYTUNE = 2,
}

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum buffer_constraint {
    MDB_DEFAULT = 0,
    MDB_STRICT_ISO = 1,
    MDB_MAXIMUM = 2,
}

pub enum lame_global_flags { }
pub type lame_t = *mut lame_global_flags;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct lame_version_t {
    pub major: c_int,
    pub minor: c_int,
    pub alpha: c_int,
    pub beta: c_int,
    pub psy_major: c_int,
    pub psy_minor: c_int,
    pub psy_alpha: c_int,
    pub psy_beta: c_int,
    pub features: *const c_char,
}

impl ::std::default::Default for lame_version_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub enum hip_global_flags { }
pub type hip_t = *mut hip_global_flags;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct mp3data_struct {
    pub header_parsed: c_int,
    pub stereo: c_int,
    pub samplerate: c_int,
    pub bitrate: c_int,
    pub mode: c_int,
    pub mode_ext: c_int,
    pub framesize: c_int,
    pub nsamp: c_ulong,
    pub totalframes: c_int,
    pub framenum: c_int,
}

impl ::std::default::Default for mp3data_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum lame_errorcodes_t {
    LAME_OKAY = 0,
    LAME_GENERICERROR = -1,
    LAME_NOMEM = -10,
    LAME_BADBITRATE = -11,
    LAME_BADSAMPFREQ = -12,
    LAME_INTERNALERROR = -13,
    FRONTEND_READERROR = -80,
    FRONTEND_WRITEERROR = -81,
    FRONTEND_FILETOOLARGE = -82,
}
pub const LAME_NOERROR: lame_errorcodes_t = lame_errorcodes_t::LAME_OKAY;

extern "C" {
    pub static mut bitrate_table: [[c_int; 16usize]; 3usize];
    pub static mut samplerate_table: [[c_int; 4usize]; 3usize];
    pub fn lame_init() -> *mut lame_global_flags;
    pub fn lame_set_num_samples(arg1: *mut lame_global_flags, arg2: c_ulong) -> c_int;
    pub fn lame_get_num_samples(arg1: *const lame_global_flags) -> c_ulong;
    pub fn lame_set_in_samplerate(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_in_samplerate(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_num_channels(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_num_channels(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_scale(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_scale(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_scale_left(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_scale_left(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_scale_right(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_scale_right(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_out_samplerate(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_out_samplerate(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_analysis(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_analysis(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_bWriteVbrTag(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_bWriteVbrTag(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_decode_only(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_decode_only(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_quality(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_quality(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_mode(arg1: *mut lame_global_flags, arg2: MPEG_mode) -> c_int;
    pub fn lame_get_mode(arg1: *const lame_global_flags) -> MPEG_mode;
    pub fn lame_set_force_ms(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_force_ms(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_free_format(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_free_format(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_findReplayGain(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_findReplayGain(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_decode_on_the_fly(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_decode_on_the_fly(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_nogap_total(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_nogap_total(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_nogap_currentindex(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_nogap_currentindex(arg1: *const lame_global_flags) -> c_int;
    // TODO: va_list support
    // pub fn lame_set_errorf(arg1: *mut lame_global_flags, arg2: lame_report_function) -> c_int;
    // pub fn lame_set_debugf(arg1: *mut lame_global_flags, arg2: lame_report_function) -> c_int;
    // pub fn lame_set_msgf(arg1: *mut lame_global_flags, arg2: lame_report_function) -> c_int;
    pub fn lame_set_brate(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_brate(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_compression_ratio(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_compression_ratio(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_preset(gfp: *mut lame_global_flags, arg1: c_int) -> c_int;
    pub fn lame_set_asm_optimizations(gfp: *mut lame_global_flags,
                                      arg1: c_int,
                                      arg2: c_int)
                                      -> c_int;
    pub fn lame_set_copyright(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_copyright(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_original(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_original(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_error_protection(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_error_protection(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_extension(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_extension(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_strict_ISO(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_strict_ISO(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_disable_reservoir(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_disable_reservoir(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_quant_comp(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_quant_comp(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_quant_comp_short(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_quant_comp_short(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_experimentalX(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_experimentalX(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_experimentalY(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_experimentalY(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_experimentalZ(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_experimentalZ(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_exp_nspsytune(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_exp_nspsytune(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_msfix(arg1: *mut lame_global_flags, arg2: f64);
    pub fn lame_get_msfix(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_VBR(arg1: *mut lame_global_flags, arg2: vbr_mode) -> c_int;
    pub fn lame_get_VBR(arg1: *const lame_global_flags) -> vbr_mode;
    pub fn lame_set_VBR_q(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_VBR_q(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_VBR_quality(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_VBR_quality(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_VBR_mean_bitrate_kbps(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_VBR_mean_bitrate_kbps(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_VBR_min_bitrate_kbps(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_VBR_min_bitrate_kbps(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_VBR_max_bitrate_kbps(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_VBR_max_bitrate_kbps(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_VBR_hard_min(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_VBR_hard_min(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_lowpassfreq(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_lowpassfreq(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_lowpasswidth(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_lowpasswidth(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_highpassfreq(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_highpassfreq(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_highpasswidth(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_highpasswidth(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_ATHonly(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_ATHonly(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_ATHshort(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_ATHshort(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_noATH(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_noATH(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_ATHtype(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_ATHtype(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_ATHlower(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_ATHlower(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_athaa_type(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_athaa_type(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_athaa_sensitivity(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_athaa_sensitivity(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_allow_diff_short(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_allow_diff_short(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_useTemporal(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_useTemporal(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_interChRatio(arg1: *mut lame_global_flags, arg2: f32) -> c_int;
    pub fn lame_get_interChRatio(arg1: *const lame_global_flags) -> f32;
    pub fn lame_set_no_short_blocks(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_no_short_blocks(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_force_short_blocks(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_force_short_blocks(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_set_emphasis(arg1: *mut lame_global_flags, arg2: c_int) -> c_int;
    pub fn lame_get_emphasis(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_version(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_encoder_delay(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_encoder_padding(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_framesize(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_mf_samples_to_encode(gfp: *const lame_global_flags) -> c_int;
    pub fn lame_get_size_mp3buffer(gfp: *const lame_global_flags) -> c_int;
    pub fn lame_get_frameNum(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_totalframes(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_RadioGain(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_AudiophileGain(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_PeakSample(arg1: *const lame_global_flags) -> f32;
    pub fn lame_get_noclipGainChange(arg1: *const lame_global_flags) -> c_int;
    pub fn lame_get_noclipScale(arg1: *const lame_global_flags) -> f32;
    pub fn lame_init_params(arg1: *mut lame_global_flags) -> c_int;
    pub fn get_lame_version() -> *const c_char;
    pub fn get_lame_short_version() -> *const c_char;
    pub fn get_lame_very_short_version() -> *const c_char;
    pub fn get_psy_version() -> *const c_char;
    pub fn get_lame_url() -> *const c_char;
    pub fn get_lame_os_bitness() -> *const c_char;
    pub fn get_lame_version_numerical(arg1: *mut lame_version_t);
    pub fn lame_print_config(gfp: *const lame_global_flags);
    pub fn lame_print_internals(gfp: *const lame_global_flags);
    pub fn lame_encode_buffer(gfp: *mut lame_global_flags,
                              buffer_l: *mut c_short,
                              buffer_r: *mut c_short,
                              nsamples: c_int,
                              mp3buf: *mut c_uchar,
                              mp3buf_size: c_int)
                              -> c_int;
    pub fn lame_encode_buffer_interleaved(gfp: *mut lame_global_flags,
                                          pcm: *mut c_short,
                                          num_samples: c_int,
                                          mp3buf: *mut c_uchar,
                                          mp3buf_size: c_int)
                                          -> c_int;
    pub fn lame_encode_buffer_float(gfp: *mut lame_global_flags,
                                    pcm_l: *mut f32,
                                    pcm_r: *mut f32,
                                    nsamples: c_int,
                                    mp3buf: *mut c_uchar,
                                    mp3buf_size: c_int)
                                    -> c_int;
    pub fn lame_encode_buffer_ieee_float(gfp: lame_t,
                                         pcm_l: *mut f32,
                                         pcm_r: *mut f32,
                                         nsamples: c_int,
                                         mp3buf: *mut c_uchar,
                                         mp3buf_size: c_int)
                                         -> c_int;
    pub fn lame_encode_buffer_interleaved_ieee_float(gfp: lame_t,
                                                     pcm: *mut f32,
                                                     nsamples: c_int,
                                                     mp3buf: *mut c_uchar,
                                                     mp3buf_size: c_int)
                                                     -> c_int;
    pub fn lame_encode_buffer_ieee_double(gfp: lame_t,
                                          pcm_l: *mut f64,
                                          pcm_r: *mut f64,
                                          nsamples: c_int,
                                          mp3buf: *mut c_uchar,
                                          mp3buf_size: c_int)
                                          -> c_int;
    pub fn lame_encode_buffer_interleaved_ieee_double(gfp: lame_t,
                                                      pcm: *mut f64,
                                                      nsamples: c_int,
                                                      mp3buf: *mut c_uchar,
                                                      mp3buf_size: c_int)
                                                      -> c_int;
    pub fn lame_encode_buffer_long(gfp: *mut lame_global_flags,
                                   buffer_l: *mut c_long,
                                   buffer_r: *mut c_long,
                                   nsamples: c_int,
                                   mp3buf: *mut c_uchar,
                                   mp3buf_size: c_int)
                                   -> c_int;
    pub fn lame_encode_buffer_long2(gfp: *mut lame_global_flags,
                                    buffer_l: *mut c_long,
                                    buffer_r: *mut c_long,
                                    nsamples: c_int,
                                    mp3buf: *mut c_uchar,
                                    mp3buf_size: c_int)
                                    -> c_int;
    pub fn lame_encode_buffer_int(gfp: *mut lame_global_flags,
                                  buffer_l: *mut c_int,
                                  buffer_r: *mut c_int,
                                  nsamples: c_int,
                                  mp3buf: *mut c_uchar,
                                  mp3buf_size: c_int)
                                  -> c_int;
    pub fn lame_encode_flush(gfp: *mut lame_global_flags,
                             mp3buf: *mut c_uchar,
                             size: c_int)
                             -> c_int;
    pub fn lame_encode_flush_nogap(gfp: *mut lame_global_flags,
                                   mp3buf: *mut c_uchar,
                                   size: c_int)
                                   -> c_int;
    pub fn lame_init_bitstream(gfp: *mut lame_global_flags) -> c_int;
    pub fn lame_bitrate_hist(gfp: *const lame_global_flags, bitrate_count: *mut c_int);
    pub fn lame_bitrate_kbps(gfp: *const lame_global_flags, bitrate_kbps: *mut c_int);
    pub fn lame_stereo_mode_hist(gfp: *const lame_global_flags, stereo_mode_count: *mut c_int);
    pub fn lame_bitrate_stereo_mode_hist(gfp: *const lame_global_flags,
                                         bitrate_stmode_count: *mut [c_int; 4usize]);
    pub fn lame_block_type_hist(gfp: *const lame_global_flags, btype_count: *mut c_int);
    pub fn lame_bitrate_block_type_hist(gfp: *const lame_global_flags,
                                        bitrate_btype_count: *mut [c_int; 6usize]);
    pub fn lame_mp3_tags_fid(arg1: *mut lame_global_flags, fid: *mut FILE);
    pub fn lame_get_lametag_frame(arg1: *const lame_global_flags,
                                  buffer: *mut c_uchar,
                                  size: size_t)
                                  -> size_t;
    pub fn lame_close(arg1: *mut lame_global_flags) -> c_int;
    pub fn hip_decode_init() -> hip_t;
    pub fn hip_decode_exit(gfp: hip_t) -> c_int;
    // TODO: va_list support
    // pub fn hip_set_errorf(gfp: hip_t, f: lame_report_function);
    // pub fn hip_set_debugf(gfp: hip_t, f: lame_report_function);
    // pub fn hip_set_msgf(gfp: hip_t, f: lame_report_function);
    pub fn hip_decode(gfp: hip_t,
                      mp3buf: *mut c_uchar,
                      len: size_t,
                      pcm_l: *mut c_short,
                      pcm_r: *mut c_short)
                      -> c_int;
    pub fn hip_decode_headers(gfp: hip_t,
                              mp3buf: *mut c_uchar,
                              len: size_t,
                              pcm_l: *mut c_short,
                              pcm_r: *mut c_short,
                              mp3data: *mut mp3data_struct)
                              -> c_int;
    pub fn hip_decode1(gfp: hip_t,
                       mp3buf: *mut c_uchar,
                       len: size_t,
                       pcm_l: *mut c_short,
                       pcm_r: *mut c_short)
                       -> c_int;
    pub fn hip_decode1_headers(gfp: hip_t,
                               mp3buf: *mut c_uchar,
                               len: size_t,
                               pcm_l: *mut c_short,
                               pcm_r: *mut c_short,
                               mp3data: *mut mp3data_struct)
                               -> c_int;
    pub fn hip_decode1_headersB(gfp: hip_t,
                                mp3buf: *mut c_uchar,
                                len: size_t,
                                pcm_l: *mut c_short,
                                pcm_r: *mut c_short,
                                mp3data: *mut mp3data_struct,
                                enc_delay: *mut c_int,
                                enc_padding: *mut c_int)
                                -> c_int;
    pub fn id3tag_genre_list(handler:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                c_int,
                                                                            arg2:
                                                                                *const c_char,
                                                                            arg3:
                                                                                *mut c_void)>,
                             cookie: *mut c_void);
    pub fn id3tag_init(gfp: lame_t);
    pub fn id3tag_add_v2(gfp: lame_t);
    pub fn id3tag_v1_only(gfp: lame_t);
    pub fn id3tag_v2_only(gfp: lame_t);
    pub fn id3tag_space_v1(gfp: lame_t);
    pub fn id3tag_pad_v2(gfp: lame_t);
    pub fn id3tag_set_pad(gfp: lame_t, n: size_t);
    pub fn id3tag_set_title(gfp: lame_t, title: *const c_char);
    pub fn id3tag_set_artist(gfp: lame_t, artist: *const c_char);
    pub fn id3tag_set_album(gfp: lame_t, album: *const c_char);
    pub fn id3tag_set_year(gfp: lame_t, year: *const c_char);
    pub fn id3tag_set_comment(gfp: lame_t, comment: *const c_char);
    pub fn id3tag_set_track(gfp: lame_t, track: *const c_char) -> c_int;
    pub fn id3tag_set_genre(gfp: lame_t, genre: *const c_char) -> c_int;
    pub fn id3tag_set_fieldvalue(gfp: lame_t, fieldvalue: *const c_char) -> c_int;
    pub fn id3tag_set_albumart(gfp: lame_t, image: *const c_char, size: size_t) -> c_int;
    pub fn lame_get_id3v1_tag(gfp: lame_t, buffer: *mut c_uchar, size: size_t) -> size_t;
    pub fn lame_get_id3v2_tag(gfp: lame_t, buffer: *mut c_uchar, size: size_t) -> size_t;
    pub fn lame_set_write_id3tag_automatic(gfp: *mut lame_global_flags, arg1: c_int);
    pub fn lame_get_write_id3tag_automatic(gfp: *const lame_global_flags) -> c_int;
    pub fn id3tag_set_textinfo_latin1(gfp: lame_t,
                                      id: *const c_char,
                                      text: *const c_char)
                                      -> c_int;
    pub fn id3tag_set_comment_latin1(gfp: lame_t,
                                     lang: *const c_char,
                                     desc: *const c_char,
                                     text: *const c_char)
                                     -> c_int;
    pub fn id3tag_set_fieldvalue_utf16(gfp: lame_t, fieldvalue: *const c_ushort) -> c_int;
    pub fn id3tag_set_textinfo_utf16(gfp: lame_t,
                                     id: *const c_char,
                                     text: *const c_ushort)
                                     -> c_int;
    pub fn id3tag_set_comment_utf16(gfp: lame_t,
                                    lang: *const c_char,
                                    desc: *const c_ushort,
                                    text: *const c_ushort)
                                    -> c_int;
    pub fn lame_get_bitrate(mpeg_version: c_int, table_index: c_int) -> c_int;
    pub fn lame_get_samplerate(mpeg_version: c_int, table_index: c_int) -> c_int;
}
